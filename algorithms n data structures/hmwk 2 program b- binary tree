//
//  main.cpp
//  alg 2 a
//
//  Created by Autumn Tiede on 11/10/23.
//
// create binary tree with integer elements. implement insert, search, print, and delte operations and perform the following actions:

// b) insert all non negative numbers from the tree in the queue implemented as doubly linked list

#include <iostream>
#include <queue>
using namespace std;

class Node { // creates nodes for binary tree
public:
    int key;
    Node* left; // accessible members outside of class
    Node* right;

    Node(int k) { // constructor
        key = k;
        left = right = nullptr; // when node created, has no left or right child
    }
};

class BinaryTree { // private class for the binary tree
private:
    Node* root;

    Node* insertRecursively(Node* root, int key) { // inserting elements to tree
        if (root == nullptr) { // if root = 0
            return new Node(key); // create new node
        }

        if (key < root->key) { // putting new node left or right depending on value
            root->left = insertRecursively(root->left, key);
        } else if (key > root->key) {
            root->right = insertRecursively(root->right, key);
        }

        return root;
    }

    void inOrderTraversal(Node* root) { // putting items in starting from left
        if (root != nullptr) {
            inOrderTraversal(root->left);
            cout << root->key << " ";
            inOrderTraversal(root->right);
        }
    }

    Node* searchRecursively(Node* root, int key) { // for searching for an item
        if (root == nullptr || root->key == key) { // returns value if found
            return root;
        }

        if (key < root->key) {
            return searchRecursively(root->left, key);
        }

        return searchRecursively(root->right, key);
    }

    Node* deleteRecursively(Node* root, int key) { // deletes elements
        if (root == nullptr) { // if doesnt exist, return nothing
            return root;
        }

        if (key < root->key) { // checking right and left sides
            root->left = deleteRecursively(root->left, key);
        } else if (key > root->key) {
            root->right = deleteRecursively(root->right, key);
        } else {
            if (root->left == nullptr) {
                Node* temp = root->right;
                delete root;
                return temp;
            } else if (root->right == nullptr) {
                Node* temp = root->left;
                delete root;
                return temp;
            }

            Node* temp = root->right;
            while (temp->left != nullptr) {
                temp = temp->left;
            }

            root->key = temp->key;
            root->right = deleteRecursively(root->right, temp->key);
        }
        return root;
    }

    void collectPositives(Node* root, queue<int>& positiveQueue) { // deletes elements
        if (root != nullptr) {
            collectPositives(root->left, positiveQueue);
            if (root->key > 0) {
                positiveQueue.push(root->key);
            }
            collectPositives(root->right, positiveQueue);
        }
    }

public:
    BinaryTree() { // initializing values
        root = nullptr;
    }

    void insert(int key) {
        root = insertRecursively(root, key);
    }

    void printTree() {
        inOrderTraversal(root);
        cout << endl;
    }

    bool search(int key) {
        return searchRecursively(root, key) != nullptr;
    }

    void remove(int key) {
        root = deleteRecursively(root, key);
    }

    queue<int> collectNegatives() {
        queue<int> negativesQueue;
        collectPositives(root, negativesQueue);
        return negativesQueue;
    }
};

int main() {
    int num, choice = 0, search_num = 0, delete_num = 0;
    
    bool program_run = true;
    while (program_run){
        // starting menu
        cout << "\nPress 1 to search for an element in the tree" << endl;
        cout << "Press 2 to delete an element in the tree" << endl;
        cout << "Press 3 to implement all positive numbers in the tree as doubly linked list." << endl;
        cout << "Press 4 to exit the program" << endl;
        cin >> choice;
        
        if (choice == 4){ // return
            program_run = false;
            return 0;
        }
        
        BinaryTree tree; // making the tree
        cout << "How many elements do you want to add to the tree?: ";
        cin >> num;
        int elements[num];
        
        cout << "Please enter " << num << " elements: ";
        for (int i = 0; i < num; i++){
            cin >> elements[i];
        }
        for (int element : elements) {
            tree.insert(element);
        }
        cout << "\nOriginal Tree: ";
        tree.printTree();
        
        
        if (choice == 1){ // searching
            cout << "Which integer would you like to search for?: ";
            cin >> search_num;
            int searchKey = search_num;
            if (tree.search(searchKey)) {
                cout << searchKey << " is found in the tree" << endl;
            } else {
                cout << searchKey << " is not found in the tree" << endl;
            }
        }
        
        if (choice == 2){ // deleting
            cout << "Which integer would you like to delete?: ";
            cin >> delete_num;
            int deleteKey = delete_num;
            tree.remove(deleteKey);
            cout << "Deleted " << deleteKey << " from the tree" << endl;
            cout << "Tree after deletion: ";
            tree.printTree();
        }
        
        if (choice == 3){ // negatives to doubly linked
            queue<int> positives = tree.collectNegatives();
            cout << "Positive numbers collected in the queue: ";
            while (!positives.empty()) {
                cout << positives.front() << " ";
                positives.pop();
            }
            cout << endl;
        }
    }

    cout << "\n";
    return 0;
}


